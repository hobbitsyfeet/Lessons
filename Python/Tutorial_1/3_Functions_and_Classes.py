"""
3_Functions.py

Author: Justin Petluk
Date: April 24, 2020

"""
'''
We've seen functions before. Things like print() and int()

Functions in python are made up with the scope of variables (what it can access)
as well as the variables/objects you pass in, and the name of the function.

Ofthen the name of the function describes what it does, and additional documentation
is very useful while creating functions for other people to use.
'''
#Often in classes, when a constant such as PI is defined outside of the scope of any function
#this allows everything that imports this file to use it.
A_GLOBAL_CONSTANT = 0
PI = 3.14159265


#We can define an empty function like this. It does not need to have any parameters passed in though.
#An empty function is useful for building up a class to understand fully what it needs.
#In 'practice', I never do it but UML diagrams help design classes, variables and
#relationships. So filling out empty functions and getting to know their relationships can 
#be quite useful
def function_name(var_1, var_2):
    pass

#Note how we define functions before we enter main?
#I personally like to use main to quickly test out functions I create to see if they work.
#Though, we will get into unit testing and proper forms of assuring our code works!

def add(first_num, second_num):
    '''
    In Microsoft VS Code, Documentation of a function can be generated by using multi-line comments immediately
    after declaration!
    '''
    #when we pass in variables, these exist only within the scope of the function.
    #And these variables, like many others are named to help the reader understand.

    #return is the value that the function is equal to at the end. It exsits the function
    return first_num + second_num

def remove_chars(string, char_to_filter):
    '''
    Remove all characters within a string.
    '''
    temp_string = ""
    #iterate through every character in the string using index values
    #It just goes from 0-length of string.
    for char_index in range(len(string)):
        if string[char_index] != char_to_filter: #Compare character at current index to char to filter
            temp_string += string[char_index] #assign the string index to an empty string, removing the character.

    return temp_string

class personal_list(): #<- This parameter passes in things you INHERIT from, 
                             #common in Objected Oriented Programming

    ''' Like functions, you can quickly document a class like this!
        Note: We're creating a redundant collection of functions and variables
        To express the syntax and methods of creating this. Python has it's on list
        manipulating functions.
    '''
    def __init__(self, beginning_list=[]):
        ''' This function is required in every class. It defines
            What happens when you initialize an object, or "class"
            Self refers to the class itself. It's what contains it's own scope of variables
            Let's create a collection of functions that can manipulate an object's list!
        '''
        #We define everthing we want to keep within the class with self.

        self.list = beginning_list #Notice i set beginning_list = []? This allows the user to define a list,
                                    #But if the list is left empty when creating the object, it defaults to []
                                    #Similarly to how end="\n" in print()

        self.first_value = None #Notice the purpose of None? We do not have anything in the list yet.
        self.last_value = None
        self.lowest_value = None
        self.highest_value = None
        temperary_variable = "I will be non-existant outside of __init__"

        #We can call processes when the object is created.
        self.assign_attributes()

        #These initialized variables Belong to this object. If multiple instances of the object is created, each
        #will have their own set of variables.

    def assign_attributes(self):
        '''
        Defines attributes such as first_value in a more complex manner.
        It will check and assign things accordingly.
        '''
        #Notice we pass in self. This is basically passing everything we defined in __init__ to the function
        
        if self.list is not None and len(self.list) > 0:
            self.first_value = self.list[0] #set it to  value at fist index
            self.last_value = self.list[-1] #Set it to value at last index

            #Now that we know the list is not empty, let's check for
            low_value = None
            high_value = None


            if len(self.list) >= 2: #Make sure it has multiple values
                for value in self.list:

                    #Check the lowest value
                    if low_value == None:
                        low_value = value
                        high_value = value

                    elif value < low_value:
                        low_value = value

                    elif value > high_value:
                        high_value = value
                
                #After we find the high and lows, we assign it to the class values
                self.lowest_value = low_value
                self.highest_value = high_value
        
            else: #There's only one value
                self.lowest_value = self.first_value

''' So what we just did was we assigned the values within an unsorted list.
    When complex functions like this are being done, the key thing to do is DRAW IT OUT
    No one creates things right the first time, it took me a couple times to get this done.
    So they best thing to do is spend some time understanding the problem, document your progress and why you do things
    Make code easy to read and clear. This way it's easier to locate mistakes and understand why it went wrong.
'''

if __name__ == "__main__":
    function_name(1,2)

    #Add 2 numbers
    number = add(1,1)
    print(number)

    #Filter a string
    new_string = remove_chars("H|E|L||||L|O", "|")
    print(new_string)

    # Create a personal_list structure!
    new_list = personal_list()
    #we can access the self variables and functions using the dot operator.
    #we access new_list's self.list by new_list.list
    new_list.list = [8, 3, 1, 12, 11, 0]

    #Let's assing the highest and lowest values
    new_list.assign_attributes() #<- Functions always need these parenthesis

    print(new_list.list) #While variables do not use parenthesis.
    print("List lowest value:", new_list.lowest_value)

    odd_list = personal_list([1,3,5,7,9])
    even_list = personal_list([2,4,6,8,10])

    print("Even list highest value:", even_list.highest_value)
    print("Odd list highest value:", odd_list.highest_value)

    #It's handy to note that strings compare in alphabhetical order! by default!
    list_of_strings = personal_list(["HELLLO", "THERE", "GOOD", "Bye"])
    print("Lowest value in list of strings:", list_of_strings.highest_value)
    print("Highest value in strings:", list_of_strings.lowest_value)
    #Python has no such thing as private or public methods and attributes li
